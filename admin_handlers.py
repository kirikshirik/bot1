–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ\! –°–ø–∞—Å–∏–±–æ –∑–∞ —Å–∫—Ä–∏–Ω—à–æ—Ç, –æ–Ω –æ—á–µ–Ω—å –ø–æ–º–æ–≥–∞–µ—Ç –ø–æ–Ω—è—Ç—å —Å–∏—Ç—É–∞—Ü–∏—é.

–ü—Ä–æ–±–ª–µ–º–∞ –Ω–µ –≤ —Ç–æ–º, —á—Ç–æ –æ—Ç—á–µ—Ç—ã "–Ω–µ —Ä–∞–±–æ—Ç–∞—é—Ç" –≤ —Ü–µ–ª–æ–º, –∞ –≤ —Ç–æ–º, —á—Ç–æ –æ–Ω–∏ **–Ω–µ –Ω–∞—Ö–æ–¥—è—Ç –∑–∞–ø–∏—Å–µ–π**, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –≤—Ä–µ–º–µ–Ω–Ω—ã–º —Ä–∞–º–∫–∞–º —Ç–µ–∫—É—â–µ–π –∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Å–º–µ–Ω—ã. –í–∞—à –±–æ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —ç—Ç–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä–∞–º–∫–∏, –Ω–æ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –≤ –∫—ç—à–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ Google –¢–∞–±–ª–∏—Ü –Ω–∏ –æ–¥–Ω–∞ –∏–∑ –∑–∞–ø–∏—Å–µ–π –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –ø–æ–ø–∞–¥–∞–Ω–∏–µ –≤ —ç—Ç–æ—Ç –¥–∏–∞–ø–∞–∑–æ–Ω.

–ò–∑ –Ω–∞—à–∏—Ö –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –ª–æ–≥–æ–≤ –º—ã –∑–Ω–∞–µ–º, —á—Ç–æ –≤—ã —Å–æ–∑–¥–∞–≤–∞–ª–∏ –∑–∞–ø–∏—Å–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ 13:30). –¢–∞–∫–∞—è –∑–∞–ø–∏—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã–ª–∞ –ø–æ–ø–∞—Å—Ç—å –≤ –æ—Ç—á–µ—Ç –∑–∞ —Ç–µ–∫—É—â—É—é —Å–º–µ–Ω—É (—Å 08:00 –ø–æ 20:00). –†–∞–∑ —ç—Ç–æ–≥–æ –Ω–µ –ø—Ä–æ–∏–∑–æ—à–ª–æ, –Ω–∞–∏–±–æ–ª–µ–µ –≤–µ—Ä–æ—è—Ç–Ω–∞—è –ø—Ä–∏—á–∏–Ω–∞ ‚Äî **–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ñ–æ—Ä–º–∞—Ç–∞ –¥–∞—Ç—ã**.

–°–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, Google –¢–∞–±–ª–∏—Ü—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏–∑–º–µ–Ω—è—é—Ç —Ñ–æ—Ä–º–∞—Ç —è—á–µ–π–∫–∏ —Å –¥–∞—Ç–æ–π, –∏ –∫–æ–¥ –Ω–µ –º–æ–∂–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ø—Ä–æ—á–∏—Ç–∞—Ç—å —ç—Ç–æ –∏–∑–º–µ–Ω–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.

### –†–µ—à–µ–Ω–∏–µ: –¥–µ–ª–∞–µ–º –∫–æ–¥ –±–æ–ª–µ–µ —É—Å—Ç–æ–π—á–∏–≤—ã–º –∫ —Ñ–æ—Ä–º–∞—Ç–∞–º –¥–∞—Ç

–Ø –≤–Ω–µ—Å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –¥–≤–∞ —Ñ–∞–π–ª–∞, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å —Å–∏—Å—Ç–µ–º—É –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ–π:

1.  **`reports.py`**: –û–±–Ω–æ–≤–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ —á—Ç–µ–Ω–∏—è –¥–∞—Ç. –¢–µ–ø–µ—Ä—å –∫–æ–¥ –±—É–¥–µ—Ç –ø—ã—Ç–∞—Ç—å—Å—è —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –µ–≥–æ –≥–æ—Ä–∞–∑–¥–æ –±–æ–ª–µ–µ —É—Å—Ç–æ–π—á–∏–≤—ã–º –∫ –∞–≤—Ç–æ—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—é Google.
2.  **`admin_handlers.py`**: –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–µ–±–æ–ª—å—à–∞—è –æ—à–∏–±–∫–∞, —Å–≤—è–∑–∞–Ω–Ω–∞—è —Å —á–∞—Å–æ–≤—ã–º –ø–æ—è—Å–æ–º –ø—Ä–∏ –≤–Ω–µ—Å–µ–Ω–∏–∏ "–ø—Ä–æ—à–µ–¥—à–µ–≥–æ –ø—Ä–æ—Å—Ç–æ—è".

–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ —ç—Ç–∏ –¥–≤–∞ —Ñ–∞–π–ª–∞.

### 1\. –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –∫–æ–¥ –¥–ª—è `reports.py`

–ü–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–º–µ–Ω–∏—Ç–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞ `reports.py` –Ω–∞ –∫–æ–¥ –Ω–∏–∂–µ:

```python
# utils/reports.py
import logging
from datetime import datetime, timedelta, time
from collections import Counter, defaultdict
from pytz import timezone

from aiogram.utils.markdown import escape_md
from aiogram import Bot

from config import (SCHEDULER_TIMEZONE, TOP_N_REASONS_FOR_SUMMARY,
                    PRODUCTION_SITES, LINES_SECTIONS, ADMIN_ROLE)
from utils.storage import DataStorage

def get_shift_time_range(shift_type: str) -> (datetime, datetime):
    tz = timezone(SCHEDULER_TIMEZONE)
    now_local = datetime.now(tz)
    time_08_00 = time(8, 0)
    time_20_00 = time(20, 0)

    if time_08_00 <= now_local.time() < time_20_00:
        current_start = now_local.replace(hour=8, minute=0, second=0, microsecond=0)
        current_end = now_local.replace(hour=20, minute=0, second=0, microsecond=0)
    else:
        if now_local.time() >= time_20_00:
            current_start = now_local.replace(hour=20, minute=0, second=0, microsecond=0)
            current_end = (now_local + timedelta(days=1)).replace(hour=8, minute=0, second=0, microsecond=0)
        else:
            current_start = (now_local - timedelta(days=1)).replace(hour=20, minute=0, second=0, microsecond=0)
            current_end = now_local.replace(hour=8, minute=0, second=0, microsecond=0)

    if shift_type == 'current':
        return current_start, current_end
    elif shift_type == 'previous':
        if current_start.time() == time_08_00:
            prev_end = current_start
            prev_start = (current_start - timedelta(days=1)).replace(hour=20, minute=0, second=0, microsecond=0)
        else:
            prev_end = current_start
            prev_start = current_start.replace(hour=8, minute=0, second=0, microsecond=0)
        return prev_start, prev_end

    return None, None


def calculate_shift_times(record_datetime: datetime) -> (str, str):
    tz = timezone(SCHEDULER_TIMEZONE)
    record_datetime_aware = record_datetime.astimezone(tz) if record_datetime.tzinfo else tz.localize(record_datetime)
    record_date = record_datetime_aware.date()
    record_time = record_datetime_aware.time()
    time_08_00 = time(8, 0)
    time_20_00 = time(20, 0)

    if time_08_00 <= record_time < time_20_00:
        start_dt = tz.localize(datetime.combine(record_date, time_08_00))
        end_dt = tz.localize(datetime.combine(record_date, time_20_00))
    elif record_time >= time_20_00:
        start_dt = tz.localize(datetime.combine(record_date, time_20_00))
        end_dt = tz.localize(datetime.combine(record_date + timedelta(days=1), time_08_00))
    else:
        start_dt = tz.localize(datetime.combine(record_date - timedelta(days=1), time_20_00))
        end_dt = tz.localize(datetime.combine(record_date, time_08_00))

    return start_dt.strftime("%Y-%m-%d %H:%M:%S"), end_dt.strftime("%Y-%m-%d %H:%M:%S")

def _parse_datetime_from_sheet(dt_string: str) -> datetime | None:
    """–ü—ã—Ç–∞–µ—Ç—Å—è —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å —Å—Ç—Ä–æ–∫—É —Å –¥–∞—Ç–æ–π –∏–∑ —Ç–∞–±–ª–∏—Ü—ã, –ø—Ä–æ–±—É—è –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ä–º–∞—Ç–æ–≤."""
    # –°–ø–∏—Å–æ–∫ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤, –æ—Ç –Ω–∞–∏–±–æ–ª–µ–µ –≤–µ—Ä–æ—è—Ç–Ω–æ–≥–æ –∫ –º–µ–Ω–µ–µ
    formats_to_try = [
        "%Y-%m-%d %H:%M:%S",  # –ù–∞—à –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–æ—Ä–º–∞—Ç
        "%d.%m.%Y %H:%M:%S",  # –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤ –†–§
        "%Y/%m/%d %H:%M:%S",
    ]
    for fmt in formats_to_try:
        try:
            return datetime.strptime(dt_string, fmt)
        except ValueError:
            continue
    logging.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã-–≤—Ä–µ–º–µ–Ω–∏: '{dt_string}'")
    return None

async def get_downtime_report_for_period(start_dt: datetime, end_dt: datetime, storage: DataStorage):
    cache_status = ""
    if storage.downtime_cache.get("error"):
        cache_status += f"\n\n‚ö†Ô∏è **–ö—ç—à-–æ—à–∏–±–∫–∞: {storage.downtime_cache['error']}.**"
    if storage.is_cache_stale():
        cache_status += f"\n\n‚ö†Ô∏è **–î–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω—ã (–∫—ç—à —É—Å—Ç–∞—Ä–µ–ª).**"

    headers = storage.downtime_cache.get("headers")
    data_rows = storage.downtime_cache.get("data_rows")

    if not headers or data_rows is None:
        return f"–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –ø—Ä–æ—Å—Ç–æ—è—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.{cache_status}"

    try:
        required_cols = [
            "Timestamp_–∑–∞–ø–∏—Å–∏", "–ü–ª–æ—â–∞–¥–∫–∞", "–õ–∏–Ω–∏—è_–°–µ–∫—Ü–∏—è", "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ_–ø—Ä–æ—Å—Ç–æ—è",
            "–í—Ä–µ–º—è_–ø—Ä–æ—Å—Ç–æ—è_–º–∏–Ω—É—Ç", "–ü—Ä–∏—á–∏–Ω–∞_–ø—Ä–æ—Å—Ç–æ—è_–æ–ø–∏—Å–∞–Ω–∏–µ", "–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–∞—è_–≥—Ä—É–ø–ø–∞",
            "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π_–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π_–∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–∞"
        ]
        idx_map = {col: headers.index(col) for col in required_cols}
    except ValueError as e:
        logging.error(f"–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–π —Å—Ç–æ–ª–±–µ—Ü –≤ —Ç–∞–±–ª–∏—Ü–µ: {e}")
        return f"–û—à–∏–±–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –æ—Ç—á–µ—Ç–∞: —Å—Ç–æ–ª–±–µ—Ü '{str(e).split()[0]}' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Ç–∞–±–ª–∏—Ü–µ."

    downtimes_by_site = defaultdict(list)
    total_minutes = 0
    tz = timezone(SCHEDULER_TIMEZONE)

    for row in data_rows:
        try:
            if len(row) <= max(idx_map.values()): continue
            
            record_timestamp_str = row[idx_map["Timestamp_–∑–∞–ø–∏—Å–∏"]]
            if not record_timestamp_str: continue
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é –Ω–∞–¥–µ–∂–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
            record_dt = _parse_datetime_from_sheet(record_timestamp_str)
            if not record_dt: continue

            record_dt_aware = tz.localize(record_dt)

            if start_dt <= record_dt_aware < end_dt:
                site = escape_md(row[idx_map['–ü–ª–æ—â–∞–¥–∫–∞']])
                duration = int(row[idx_map["–í—Ä–µ–º—è_–ø—Ä–æ—Å—Ç–æ—è_–º–∏–Ω—É—Ç"]] or 0)
                total_minutes += duration
                description = escape_md(row[idx_map["–ü—Ä–∏—á–∏–Ω–∞_–ø—Ä–æ—Å—Ç–æ—è_–æ–ø–∏—Å–∞–Ω–∏–µ"]])
                initiator_comment = escape_md(row[idx_map["–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π_–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π_–∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–∞"]])
                line_info = (f"‚öôÔ∏è **{escape_md(row[idx_map['–õ–∏–Ω–∏—è_–°–µ–∫—Ü–∏—è']])}**: "
                             f"{escape_md(row[idx_map['–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ_–ø—Ä–æ—Å—Ç–æ—è']])} ({duration} –º–∏–Ω.)\n"
                             f"   üìù _{description}_\n"
                             f"   üë• {escape_md(row[idx_map['–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–∞—è_–≥—Ä—É–ø–ø–∞']])}")

                if initiator_comment and "–ë–µ–∑ –¥–æ–ø. –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è" not in initiator_comment:
                    line_info += f"\n   üó£Ô∏è –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–∞: _{initiator_comment}_"
                downtimes_by_site[site].append(line_info)
        except (ValueError, IndexError) as e:
            logging.warning(f"–ü—Ä–æ–ø—É—â–µ–Ω–∞ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ—Ç—á–µ—Ç–∞: {row}. –û—à–∏–±–∫–∞: {e}")
            continue

    if not downtimes_by_site:
        return f"–ù–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π –∑–∞ —Å–º–µ–Ω—É —Å {start_dt.strftime('%H:%M %d.%m')} –ø–æ {end_dt.strftime('%H:%M %d.%m')}.{cache_status}"

    report_header = f"**üìä –û—Ç—á–µ—Ç –∑–∞ —Å–º–µ–Ω—É —Å {start_dt.strftime('%H:%M %d.%m')} –ø–æ {end_dt.strftime('%H:%M %d.%m')}**\n"
    report_lines = ["\n".join(lines) for site, lines in sorted(downtimes_by_site.items())]
    report_summary = f"\n\n**‚è±Ô∏è –û–±—â–µ–µ –≤—Ä–µ–º—è –ø—Ä–æ—Å—Ç–æ—è: {total_minutes} –º–∏–Ω—É—Ç.**"
    return report_header + "\n\n".join(report_lines) + report_summary + cache_status


async def generate_admin_shift_summary(start_dt: datetime, end_dt: datetime, storage: DataStorage):
    headers = storage.downtime_cache.get("headers")
    data_rows = storage.downtime_cache.get("data_rows")

    if not headers or data_rows is None: return "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–≤–æ–¥–∫–∏."

    try:
        idx_map = {col: headers.index(col) for col in ["Timestamp_–∑–∞–ø–∏—Å–∏", "–í—Ä–µ–º—è_–ø—Ä–æ—Å—Ç–æ—è_–º–∏–Ω—É—Ç", "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ_–ø—Ä–æ—Å—Ç–æ—è"]}
    except ValueError as e: return f"–û—à–∏–±–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Å–≤–æ–¥–∫–∏: —Å—Ç–æ–ª–±–µ—Ü '{str(e).split()[0]}' –Ω–µ –Ω–∞–π–¥–µ–Ω."
    
    total_minutes = 0
    reason_counts = Counter()
    tz = timezone(SCHEDULER_TIMEZONE)

    for row in data_rows:
        try:
            if len(row) <= max(idx_map.values()): continue
            record_timestamp_str = row[idx_map["Timestamp_–∑–∞–ø–∏—Å–∏"]]
            if not record_timestamp_str: continue
            
            record_dt = _parse_datetime_from_sheet(record_timestamp_str)
            if not record_dt: continue

            record_dt_aware = tz.localize(record_dt)

            if start_dt <= record_dt_aware < end_dt:
                duration = int(row[idx_map["–í—Ä–µ–º—è_–ø—Ä–æ—Å—Ç–æ—è_–º–∏–Ω—É—Ç"]] or 0)
                reason = row[idx_map["–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ_–ø—Ä–æ—Å—Ç–æ—è"]] or "–ù–µ —É–∫–∞–∑–∞–Ω–∞"
                total_minutes += duration
                reason_counts[reason] += duration
        except (ValueError, IndexError) as e:
            logging.warning(f"–ü—Ä–æ–ø—É—â–µ–Ω–∞ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å–≤–æ–¥–∫–∏: {row}. –û—à–∏–±–∫–∞: {e}")
            continue

    if total_minutes == 0:
        return f"–ó–∞ —Å–º–µ–Ω—É ({start_dt.strftime('%H:%M')}-{end_dt.strftime('%H:%M')}) –ø—Ä–æ—Å—Ç–æ–µ–≤ –Ω–µ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–æ."

    hours, minutes = divmod(total_minutes, 60)
    top_reasons_list = reason_counts.most_common(TOP_N_REASONS_FOR_SUMMARY)
    top_reasons = [f"- {escape_md(r)} ({m} –º–∏–Ω.)" for r, m in top_reasons_list]
    summary = (f"**–°–≤–æ–¥–∫–∞ –∑–∞ —Å–º–µ–Ω—É ({start_dt.strftime('%H:%M %d.%m')})**\n\n"
               f"–û–±—â–∏–π –ø—Ä–æ—Å—Ç–æ–π: **{hours} —á {minutes} –º–∏–Ω.**\n\n"
               f"**–¢–æ–ø-{len(top_reasons)} –ø—Ä–∏—á–∏–Ω—ã:**\n" + "\n".join(top_reasons))
    return summary


async def generate_line_status_report(storage: DataStorage):
    report_lines = ["**–°—Ç–∞—Ç—É—Å –ª–∏–Ω–∏–π –Ω–∞ —Ç–µ–∫—É—â–∏–π –º–æ–º–µ–Ω—Ç:**"]
    for site_key, site_name in PRODUCTION_SITES.items():
        if site_key not in LINES_SECTIONS: continue
        report_lines.append(f"\nüè≠ **{escape_md(site_name)}**")
        for line_key, line_name in LINES_SECTIONS[site_key].items():
            line_tuple = (site_name, line_name)
            if line_tuple in storage.active_downtimes:
                reason = storage.active_downtimes[line_tuple]
                report_lines.append(f"   üî¥ {escape_md(line_name)}: **–ü–†–û–°–¢–û–ô** ({escape_md(reason)})")
            else:
                report_lines.append(f"   üü¢ {escape_md(line_name)}: –†–∞–±–æ—Ç–∞–µ—Ç")
    return "\n".join(report_lines)


async def scheduled_line_status_report(bot: Bot, storage: DataStorage):
    logging.info("SCHEDULER: –ó–∞–ø—É—Å–∫ –∑–∞–¥–∞—á–∏ –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É –æ—Ç—á–µ—Ç–∞ –æ —Å—Ç–∞—Ç—É—Å–µ –ª–∏–Ω–∏–π.")
    admin_ids = [uid for uid, role in storage.user_roles.items() if role == ADMIN_ROLE]
    if not admin_ids:
        logging.warning("SCHEDULER: –ù–µ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç—á–µ—Ç–∞ –æ —Å—Ç–∞—Ç—É—Å–µ –ª–∏–Ω–∏–π.")
        return
    report_text = await generate_line_status_report(storage)
    for admin_id in admin_ids:
        try:
            await bot.send_message(int(admin_id), report_text, parse_mode="Markdown")
        except Exception as e:
            logging.error(f"SCHEDULER: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—á–µ—Ç –æ —Å—Ç–∞—Ç—É—Å–µ –ª–∏–Ω–∏–π –∞–¥–º–∏–Ω—É {admin_id}: {e}")
    logging.info(f"SCHEDULER: –û—Ç—á–µ—Ç –æ —Å—Ç–∞—Ç—É—Å–µ –ª–∏–Ω–∏–π –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω {len(admin_ids)} –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
```

### 2\. –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –∫–æ–¥ –¥–ª—è `admin_handlers.py`

–ü–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–º–µ–Ω–∏—Ç–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞ `admin_handlers.py` –Ω–∞ –∫–æ–¥ –Ω–∏–∂–µ:

```python
# handlers/admin_handlers.py
import logging
from datetime import datetime
from aiogram import Dispatcher, types
from aiogram.dispatcher import FSMContext
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from pytz import timezone

# FSM
from fsm import AdminForm, PastDowntimeForm

# Filters, Storage, Config
from filters.admin_filter import AdminFilter
from utils.storage import DataStorage
from config import (
    USER_ID_COLUMN, USER_ROLE_COLUMN, SCHEDULER_TIMEZONE, 
    PRODUCTION_SITES, DOWNTIME_REASONS, LINES_SECTIONS
)

# Keyboards
from keyboards.inline import (
    get_admin_roles_keyboard,
    get_sites_keyboard,
    get_lines_sections_keyboard,
    get_downtime_reasons_keyboard,
    get_responsible_groups_keyboard
)

# Reports & G-Sheets API
from utils.reports import (
    get_downtime_report_for_period,
    get_shift_time_range,
    generate_line_status_report,
    calculate_shift_times
)
from g_sheets.api import get_worksheet, append_downtime_record, get_next_sequence_number

# --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–æ–ª—è–º–∏ ---
async def manage_roles_start(message: types.Message, state: FSMContext):
    await state.finish()
    await AdminForm.choosing_user_for_role.set()
    await message.answer("–í–≤–µ–¥–∏—Ç–µ Telegram ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–º—É —Ö–æ—Ç–∏—Ç–µ –Ω–∞–∑–Ω–∞—á–∏—Ç—å –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å —Ä–æ–ª—å:")

async def process_user_for_role(message: types.Message, state: FSMContext):
    dp = Dispatcher.get_current()
    storage: DataStorage = dp['storage']
    user_input_id = message.text.strip()
    if not user_input_id.isdigit():
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID. –í–≤–µ–¥–∏—Ç–µ —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã.")
        return
    current_role = storage.user_roles.get(user_input_id, "–ù–µ—Ç —Ä–æ–ª–∏")
    await state.update_data(target_user_id=user_input_id, current_role=current_role)
    await AdminForm.next()
    await message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: `{user_input_id}`\n–¢–µ–∫—É—â–∞—è —Ä–æ–ª—å: **{current_role}**\n\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—É—é —Ä–æ–ª—å:", parse_mode='Markdown', reply_markup=get_admin_roles_keyboard())

async def process_role_choice(cb: types.CallbackQuery, state: FSMContext):
    dp = Dispatcher.get_current()
    storage: DataStorage = dp['storage']
    new_role = cb.data.split('setrole_', 1)[1]
    user_data = await state.get_data()
    target_user_id = user_data.get('target_user_id')
    if not target_user_id or not storage.gspread_client:
        await cb.message.edit_text("‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        await state.finish()
        return
    try:
        roles_ws = get_worksheet(storage.gspread_client, storage.user_roles_ws.title, [USER_ID_COLUMN, USER_ROLE_COLUMN])
        cell = roles_ws.find(target_user_id, in_column=1)
        action_message = ""
        if new_role == "DELETE":
            if cell: roles_ws.delete_rows(cell.row)
            action_message = f"–†–æ–ª—å –¥–ª—è `{target_user_id}` —É–¥–∞–ª–µ–Ω–∞."
        else:
            if cell: roles_ws.update_cell(cell.row, 2, new_role)
            else: roles_ws.append_row([target_user_id, new_role])
            action_message = f"–†–æ–ª—å –¥–ª—è `{target_user_id}` —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: **{new_role}**."
        await storage.load_user_roles()
        await cb.message.edit_text(action_message, parse_mode='Markdown')
        await cb.answer("–†–æ–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞.")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ä–æ–ª–∏ –¥–ª—è {target_user_id}: {e}")
        await cb.message.edit_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å Google Sheets.")
    await state.finish()

async def cancel_admin_input(cb: types.CallbackQuery, state: FSMContext):
    await state.finish()
    await cb.message.edit_text("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    await cb.answer()

# --- –û—Ç—á–µ—Ç—ã –∏ —Å—Ç–∞—Ç—É—Å ---
async def send_shift_report(message: types.Message, shift_type: str):
    dp = Dispatcher.get_current()
    storage: DataStorage = dp['storage']
    await message.answer(f"‚è≥ –§–æ—Ä–º–∏—Ä—É—é –æ—Ç—á–µ—Ç –∑–∞ { '—Ç–µ–∫—É—â—É—é' if shift_type == 'current' else '–ø—Ä–µ–¥—ã–¥—É—â—É—é' } —Å–º–µ–Ω—É...")
    start_dt, end_dt = get_shift_time_range(shift_type)
    if not start_dt or not end_dt:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä–∞–º–∫–∏ —Å–º–µ–Ω—ã.")
        return
    report_text = await get_downtime_report_for_period(start_dt, end_dt, storage)
    max_length = 4096
    if len(report_text) > max_length:
        for i in range(0, len(report_text), max_length):
            await message.answer(report_text[i:i+max_length], parse_mode='Markdown')
    else:
        await message.answer(report_text, parse_mode='Markdown')

async def send_line_status_now(message: types.Message):
    dp = Dispatcher.get_current()
    storage: DataStorage = dp['storage']
    await message.answer("‚è≥ –§–æ—Ä–º–∏—Ä—É—é –æ—Ç—á–µ—Ç –æ —Å—Ç–∞—Ç—É—Å–µ –ª–∏–Ω–∏–π...")
    report_text = await generate_line_status_report(storage)
    await message.answer(report_text, parse_mode='Markdown')

# --- –í–Ω–µ—Å–µ–Ω–∏–µ –ø—Ä–æ—à–µ–¥—à–µ–≥–æ –ø—Ä–æ—Å—Ç–æ—è ---
async def start_past_downtime(message: types.Message, state: FSMContext):
    await state.finish()
    await PastDowntimeForm.choosing_site.set()
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–µ–Ω–Ω—É—é –ø–ª–æ—â–∞–¥–∫—É:", reply_markup=get_sites_keyboard())

async def past_downtime_site_chosen(cb: types.CallbackQuery, state: FSMContext):
    site_key = cb.data.split('_')[1]
    site_name = PRODUCTION_SITES[site_key]
    await state.update_data(site_key=site_key, site_name=site_name)
    await PastDowntimeForm.next()
    await cb.message.edit_text(
        f"–ü–ª–æ—â–∞–¥–∫–∞: {site_name}.\n–í—ã–±–µ—Ä–∏—Ç–µ –ª–∏–Ω–∏—é/—Å–µ–∫—Ü–∏—é:",
        reply_markup=get_lines_sections_keyboard(site_key)
    )
    await cb.answer()

async def past_downtime_line_chosen(cb: types.CallbackQuery, state: FSMContext):
    ls_key = cb.data.split('_')[1]
    async with state.proxy() as data:
        site_key = data['site_key']
        data['ls_key'] = ls_key
        data['ls_name'] = LINES_SECTIONS[site_key][ls_key]
    await PastDowntimeForm.next()
    await cb.message.edit_text(
        f"–õ–∏–Ω–∏—è/—Å–µ–∫—Ü–∏—è: {data['ls_name']}.\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Å—Ç–æ—è:",
        reply_markup=get_downtime_reasons_keyboard()
    )
    await cb.answer()
    
async def past_downtime_reason_chosen(cb: types.CallbackQuery, state: FSMContext):
    reason_key = cb.data.split('_', 1)[1]
    reason_name = DOWNTIME_REASONS[reason_key]
    await state.update_data(reason_key=reason_key, reason_name=reason_name)
    await PastDowntimeForm.next()
    await cb.message.edit_text(f"–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: {reason_name}.\n\n–í–≤–µ–¥–∏—Ç–µ **–¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –ù–ê–ß–ê–õ–ê** –ø—Ä–æ—Å—Ç–æ—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ\n`–î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú` (–Ω–∞–ø—Ä–∏–º–µ—Ä, `27.06.2025 21:00`).")
    await cb.answer()

async def past_downtime_start_entered(message: types.Message, state: FSMContext):
    try:
        start_time = datetime.strptime(message.text, "%d.%m.%Y %H:%M")
        await state.update_data(start_time=start_time)
        await PastDowntimeForm.next()
        await message.answer("–í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ –ø—Ä–∏–Ω—è—Ç–æ.\n\n–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ **–¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –û–ö–û–ù–ß–ê–ù–ò–Ø** –ø—Ä–æ—Å—Ç–æ—è –≤ —Ç–æ–º –∂–µ —Ñ–æ—Ä–º–∞—Ç–µ (`–î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú`).")
    except ValueError:
        await message.reply("‚ùóÔ∏è **–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.**\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è —Ç–æ—á–Ω–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ `–î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú`.")

async def past_downtime_end_entered(message: types.Message, state: FSMContext):
    try:
        end_time = datetime.strptime(message.text, "%d.%m.%Y %H:%M")
        async with state.proxy() as data:
            start_time = data.get('start_time')
            if end_time <= start_time:
                await message.reply("‚ùóÔ∏è **–û—à–∏–±–∫–∞.**\n–í—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–Ω—å—à–µ –∏–ª–∏ —Ä–∞–≤–Ω–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞—á–∞–ª–∞. –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è.")
                return
            duration_minutes = max(1, int((end_time - start_time).total_seconds() / 60))
            data['end_time'] = end_time
            data['duration_minutes'] = duration_minutes
        await PastDowntimeForm.next()
        await message.answer(f"–í—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –ø—Ä–∏–Ω—è—Ç–æ. –†–∞—Å—á–µ—Ç–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: **{duration_minutes} –º–∏–Ω.**\n\n–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–∏—á–∏–Ω—ã –ø—Ä–æ—Å—Ç–æ—è.")
    except ValueError:
        await message.reply("‚ùóÔ∏è **–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.**\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è —Ç–æ—á–Ω–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ `–î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú`.")

async def past_downtime_description_entered(message: types.Message, state: FSMContext):
    dp = Dispatcher.get_current()
    storage: DataStorage = dp['storage']
    await state.update_data(description=message.text)
    await PastDowntimeForm.next()
    await message.answer("–û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ.\n\n–í—ã–±–µ—Ä–∏—Ç–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—É—é –≥—Ä—É–ø–ø—É:", reply_markup=get_responsible_groups_keyboard(storage))

async def past_downtime_group_chosen(cb: types.CallbackQuery, state: FSMContext):
    dp = Dispatcher.get_current()
    storage: DataStorage = dp['storage']
    group_key = cb.data.split('group_', 1)[1]
    group_name = storage.responsible_groups.get(group_key, "–ù–µ —É–∫–∞–∑–∞–Ω–∞")
    await state.update_data(responsible_group_name=group_name)
    await show_past_downtime_confirmation(cb.message, state)
    await cb.answer()

async def skip_past_downtime_group(cb: types.CallbackQuery, state: FSMContext):
    await state.update_data(responsible_group_name="–ù–µ —É–∫–∞–∑–∞–Ω–∞")
    await show_past_downtime_confirmation(cb.message, state)
    await cb.answer()

async def show_past_downtime_confirmation(message: types.Message, state: FSMContext):
    data = await state.get_data()
    start_time_str = data['start_time'].strftime('%d.%m.%Y %H:%M')
    end_time_str = data['end_time'].strftime('%d.%m.%Y %H:%M')
    text = [
        "**–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ:**\n",
        f"**–ü–ª–æ—â–∞–¥–∫–∞:** {data['site_name']}", f"**–õ–∏–Ω–∏—è/–°–µ–∫—Ü–∏—è:** {data['ls_name']}",
        f"**–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:** {data['reason_name']}", f"**–ù–∞—á–∞–ª–æ –ø—Ä–æ—Å—Ç–æ—è:** {start_time_str}",
        f"**–û–∫–æ–Ω—á–∞–Ω–∏–µ –ø—Ä–æ—Å—Ç–æ—è:** {end_time_str}", f"**–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:** {data['duration_minutes']} –º–∏–Ω.",
        f"**–û–ø–∏—Å–∞–Ω–∏–µ:** {data['description']}", f"**–û—Ç–≤. –≥—Ä—É–ø–ø–∞:** {data['responsible_group_name']}\n",
        "–í—Å–µ –≤–µ—Ä–Ω–æ?"
    ]
    kb = InlineKeyboardMarkup(row_width=2).add(
        InlineKeyboardButton("‚úÖ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å", callback_data="past_downtime_save"),
        InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_input")
    )
    await PastDowntimeForm.confirming_submission.set()
    await message.edit_text("\n".join(text), parse_mode="Markdown", reply_markup=kb)

async def save_past_downtime(cb: types.CallbackQuery, state: FSMContext):
    dp = Dispatcher.get_current()
    storage: DataStorage = dp['storage']
    user = cb.from_user
    tz = timezone(SCHEDULER_TIMEZONE)

    async with state.proxy() as data:
        start_time = data.get('start_time')
        shift_start_str, shift_end_str = calculate_shift_times(start_time)
        next_seq_num = get_next_sequence_number(storage.downtime_ws)
        record_data = {
            "–ü–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –∑–∞—è–≤–∫–∏": next_seq_num,
            "Timestamp_–∑–∞–ø–∏—Å–∏": datetime.now(tz).strftime("%Y-%m-%d %H:%M:%S"),
            "ID_–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è_Telegram": user.id,
            "Username_Telegram": user.username or "N/A",
            "–ò–º—è_–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è_Telegram": f"{user.full_name} (–≤–Ω–µ—Å–µ–Ω–æ –∞–¥–º.)",
            "–ü–ª–æ—â–∞–¥–∫–∞": data.get('site_name', '–ù/–î'),
            "–õ–∏–Ω–∏—è_–°–µ–∫—Ü–∏—è": data.get('ls_name', '–ù/–î'),
            "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ_–ø—Ä–æ—Å—Ç–æ—è": data.get('reason_name', '–ù/–î'),
            "–ü—Ä–∏—á–∏–Ω–∞_–ø—Ä–æ—Å—Ç–æ—è_–æ–ø–∏—Å–∞–Ω–∏–µ": data.get('description', '–ù/–î'),
            "–í—Ä–µ–º—è_–ø—Ä–æ—Å—Ç–æ—è_–º–∏–Ω—É—Ç": data.get('duration_minutes', 0),
            "–ù–∞—á–∞–ª–æ_—Å–º–µ–Ω—ã_–ø—Ä–æ—Å—Ç–æ—è": shift_start_str, "–ö–æ–Ω–µ—Ü_—Å–º–µ–Ω—ã_–ø—Ä–æ—Å—Ç–æ—è": shift_end_str,
            "–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–∞—è_–≥—Ä—É–ø–ø–∞": data.get('responsible_group_name', '–ù–µ —É–∫–∞–∑–∞–Ω–∞'),
            "–ö—Ç–æ_–ø—Ä–∏–Ω—è–ª_–∑–∞—è–≤–∫—É_ID": "", "–ö—Ç–æ_–ø—Ä–∏–Ω—è–ª_–∑–∞—è–≤–∫—É_–ò–º—è": "", "–í—Ä–µ–º—è_–ø—Ä–∏–Ω—è—Ç–∏—è_–∑–∞—è–≤–∫–∏": "",
            "–ö—Ç–æ_–∑–∞–≤–µ—Ä—à–∏–ª_—Ä–∞–±–æ—Ç—É_–≤_–≥—Ä—É–ø–ø–µ_ID": "", "–ö—Ç–æ_–∑–∞–≤–µ—Ä—à–∏–ª_—Ä–∞–±–æ—Ç—É_–≤_–≥—Ä—É–ø–ø–µ_–ò–º—è": "", "–í—Ä–µ–º—è_–∑–∞–≤–µ—Ä—à–µ–Ω–∏—è_—Ä–∞–±–æ—Ç—ã_–≥—Ä—É–ø–ø–æ–π": "",
            "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π_–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π_–∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–∞": f"–ó–∞–ø–∏—Å—å –≤–Ω–µ—Å–µ–Ω–∞ –≤—Ä—É—á–Ω—É—é {start_time.strftime('%d.%m %H:%M')} - {data['end_time'].strftime('%d.%m %H:%M')}",
            "ID_–§–æ—Ç–æ": ""
        }
    if append_downtime_record(storage.downtime_ws, record_data):
        await storage.refresh_downtime_cache(cb.bot)
        await cb.message.edit_text(f"‚úÖ **–ó–∞–ø–∏—Å—å –æ –ø—Ä–æ—à–µ–¥—à–µ–º –ø—Ä–æ—Å—Ç–æ–µ (‚Ññ{next_seq_num}) —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!**", parse_mode='Markdown')
    else:
        await cb.message.edit_text("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ Google Sheets.")
    await state.finish()
    await cb.answer("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ")

def register_admin_handlers(dp: Dispatcher):
    dp.register_message_handler(manage_roles_start, AdminFilter(), text="‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–æ–ª—è–º–∏", state="*")
    dp.register_message_handler(process_user_for_role, state=AdminForm.choosing_user_for_role)
    dp.register_callback_query_handler(process_role_choice, lambda c: c.data.startswith('setrole_'), state=AdminForm.choosing_role_for_user)
    dp.register_callback_query_handler(cancel_admin_input, text="cancel_admin_role_input", state=AdminForm.all_states)
    dp.register_message_handler(lambda msg: send_shift_report(msg, 'current'), AdminFilter(), text="üìÑ –û—Ç—á–µ—Ç –∑–∞ —Ç–µ–∫—É—â—É—é —Å–º–µ–Ω—É", state="*")
    dp.register_message_handler(lambda msg: send_shift_report(msg, 'previous'), AdminFilter(), text="üìÑ –û—Ç—á–µ—Ç –∑–∞ –ø—Ä–µ–¥—ã–¥—É—â—É—é —Å–º–µ–Ω—É", state="*")
    dp.register_message_handler(send_line_status_now, AdminFilter(), text="üîÑ –°—Ç–∞—Ç—É—Å –ª–∏–Ω–∏–π", state="*")
    dp.register_message_handler(start_past_downtime, AdminFilter(), text="üóìÔ∏è –í–Ω–µ—Å—Ç–∏ –ø—Ä–æ—à–µ–¥—à–∏–π –ø—Ä–æ—Å—Ç–æ–π", state="*")
    dp.register_callback_query_handler(past_downtime_site_chosen, lambda c: c.data.startswith('site_'), state=PastDowntimeForm.choosing_site)
    dp.register_callback_query_handler(past_downtime_line_chosen, lambda c: c.data.startswith('ls_'), state=PastDowntimeForm.choosing_line_section)
    dp.register_callback_query_handler(past_downtime_reason_chosen, lambda c: c.data.startswith('reason_'), state=PastDowntimeForm.choosing_downtime_reason)
    dp.register_message_handler(past_downtime_start_entered, state=PastDowntimeForm.entering_downtime_start)
    dp.register_message_handler(past_downtime_end_entered, state=PastDowntimeForm.entering_downtime_end)
    dp.register_message_handler(past_downtime_description_entered, state=PastDowntimeForm.entering_description)
    dp.register_callback_query_handler(past_downtime_group_chosen, lambda c: c.data.startswith('group_'), state=PastDowntimeForm.choosing_responsible_group)
    dp.register_callback_query_handler(skip_past_downtime_group, text="skip_group_selection", state=PastDowntimeForm.choosing_responsible_group)
    dp.register_callback_query_handler(save_past_downtime, text="past_downtime_save", state=PastDowntimeForm.confirming_submission)
    dp.register_callback_query_handler(cancel_admin_input, text="cancel_input", state=[PastDowntimeForm.all_states, AdminForm.all_states])
    